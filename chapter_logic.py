import json
import random
from dotenv import load_dotenv
from classifier import Classifier
from generator import ObjectGenerator
from models import *
from server_communication.events import EventBuilder
from utils import *
from global_defines import *
import global_defines
from models import *



class ChapterLogicFight:
    """Fight logic for a chapter in a game, handling character interactions and actions."""

    
    def __init__(self, context: str, characters: List[Character] = [], language: str = "Russian"):
        self.context = context
        self.last_scene = context
        self.characters = characters        
        self.generator = ObjectGenerator()
        self.scene = None
        self.classifier = Classifier()
        self.language = language
        self.turn_order = [char.name for char in self.characters]
        self.current_turn = 0
    
    def update_scene(self, scene_name: str, changes_to_make: str):
        """
        Updates the current scene with the provided changes.
        
        :param scene_name: The name of the scene to update.
        :param changes_to_make: A string describing the changes to apply.
        """
        print(f"\n{ENTITY_COLOR}{scene_name}{Colors.RESET} {INFO_COLOR}updates attributes with:{Colors.RESET} {changes_to_make}")
        try:
            self.scene = self.generator.generate(
                pydantic_model=Scene,
                prompt=f"""
                Make following changes to the scene:
                {str(self.scene)}
                Changes to make: {changes_to_make}
                """,
                language=self.language
            )
            print(f"{SUCCESS_COLOR}‚ú® Scene updated successfully!{Colors.RESET}")
        except Exception as e:
            print(f"{ERROR_COLOR}‚ùå Error updating scene: {e}{Colors.RESET}")
            return
    
    def update_character(self, character_name: str, changes_to_make: str):
        """
        Updates a character's attributes based on the provided changes.
        
        :param character_name: The name of the character to update.
        :param changes_to_make: A string describing the changes to apply.
        """
        print(f"\n{ENTITY_COLOR}{character_name}{Colors.RESET} {INFO_COLOR}updates attributes with:{Colors.RESET} {changes_to_make}")
        try:        
            char_name_list = [char.name for char in self.characters]
            
            char_dict = {char.name: char for char in self.characters}
            
            character = char_dict.get(find_closest_match(character_name, char_name_list))

            if character:
                self.characters.remove(character) # type: ignore
            character = self.generator.generate(
                pydantic_model=Character,
                prompt=f"""
                Make following changes to the character:
                {str(character)}
                Changes to make: {changes_to_make}
                
                IMPORTANT: every change has to be reflected in character. If it is a significant modification it can be reflected in character's personality.
                """,
                language=self.language
            )
            self.characters.append(character) # type: ignore
            print(f"{SUCCESS_COLOR}‚ú® Character updated successfully!{Colors.RESET}")
        except Exception as e:
            print(f"{ERROR_COLOR}‚ùå Error updating character: {e}{Colors.RESET}")
            return
        

    def setup_fight(self):
        """
        Initializes the fight by generating objects and their actions based on the context.
        """
        print(f"\n{HEADER_COLOR}üé≤ Generating Scene...{Colors.RESET}")
        
        # scene context is the same one as the chapter context (context at creating the chapter)
        scene_d = self.classifier.generate(
            f"Generate a scene description and difficulty based on the context: {self.context}",
            NextScene
        )
            
        self.scene = self.generator.generate(
            pydantic_model=Scene,
            prompt=str(scene_d),
            context=self.context,
            language=self.language
        )

        print(f"\n{SUCCESS_COLOR}‚ú® Generated Scene:{Colors.RESET} {ENTITY_COLOR}{self.scene.name}{Colors.RESET}")
        print(f"{INFO_COLOR}üìú Description:{Colors.RESET} {self.scene.description}")


        # Here i remove unnecessary parts from the context to reduce memory usage
        self.context = self.classifier.general_text_llm_request(
        f"""
            Provide the details that matter for the next scene. 
            Store which characters are allied with which ones and what can change this alliance. Store their motivations and goals.
            Dont ask additional information.
            Imagine where all the players should be located in the scene. Dont analyze characters at all.
            Give more attention to the script and story and less to the scene and characters details.
            IMPORTANT: Keep your response maximum {MAX_CONTEXT_LENGTH} words.
            ---
            {self.get_actual_context()}
        """
        )
        
        self.turn_order = [char.name for char in self.characters]
        random.shuffle(self.turn_order)
        print(f"{INFO_COLOR}Turn order shuffled{Colors.RESET}")
        
        
    def move_to_next_turn(self):
        self.current_turn = (self.current_turn + 1) % len(self.turn_order) # type: ignore

    def get_active_character_name(self) -> str:
        return self.turn_order[self.current_turn] # type: ignore

    def get_active_character(self) -> Character: # type: ignore
        for character in self.characters:
            if character.name == self.get_active_character_name():
                return character

    def get_actual_context(self) -> str:
        context_dict = {
            "world_state": {
                "summary_of_past_events": self.context,
                "current_scene": self.scene.model_dump() if self.scene else None,
            },
            "participants": {
                "all_characters": [char.model_dump() for char in self.characters]
            }
        }

        data =  f"""
    <CONTEXT_DATA>
    {json.dumps(context_dict, indent=2, ensure_ascii=False)}
    </CONTEXT_DATA>
    """
        # print(data)
        return data
       
    def get_action_prompt(self, character: Character, action_text: str) -> str:
        """
        Generates a prompt for the LLM to act as a Dungeon Master,
        evaluating a character's action with a strong emphasis on rules and legality.
        """
        return f"""
    <ROLE>
    {global_defines.dungeon_master_core_prompt}
    </ROLE>

    <RULES>
    –¢–≤–æ—è —Ä–∞–±–æ—Ç–∞ –¥–µ–ª–∏—Ç—Å—è –Ω–∞ –¥–≤–∞ —ç—Ç–∞–ø–∞: —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–µ–π—Å—Ç–≤–∏—è, –∑–∞—Ç–µ–º ‚Äî —Å–∏–º—É–ª—è—Ü–∏—è –µ–≥–æ –∏—Å—Ö–æ–¥–∞.

    **–≠–¢–ê–ü 1: –ü–†–û–í–ï–†–ö–ê –í–û–ó–ú–û–ñ–ù–û–°–¢–ò –î–ï–ô–°–¢–í–ò–Ø (–ó–ê–ö–û–ù–ù–û–°–¢–¨)**
    1.  **–≠—Ç–æ —Ç–≤–æ–π –ø–µ—Ä–≤—ã–π –∏ –≥–ª–∞–≤–Ω—ã–π —à–∞–≥.** –ü—Ä–µ–∂–¥–µ —á–µ–º —á—Ç–æ-–ª–∏–±–æ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞—Ç—å, –æ–ø—Ä–µ–¥–µ–ª–∏, –º–æ–∂–µ—Ç –ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂ –≤–æ–æ–±—â–µ —Å–æ–≤–µ—Ä—à–∏—Ç—å —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ (`is_legal`).
    2.  **–ü—Ä–æ–≤–µ—Ä—å —Å–ª–µ–¥—É—é—â–∏–µ —É—Å–ª–æ–≤–∏—è:**
        *   **–ü—Ä–µ–¥–º–µ—Ç—ã:** –ï—Å—Ç—å –ª–∏ —É –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–π –ø—Ä–µ–¥–º–µ—Ç? (–ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å—Ç—å –ª–∏ —É –Ω–µ–≥–æ –º–µ—á –¥–ª—è –∞—Ç–∞–∫–∏ –º–µ—á–æ–º? –ï—Å—Ç—å –ª–∏ –∑–µ–ª—å–µ, —á—Ç–æ–±—ã –µ–≥–æ –≤—ã–ø–∏—Ç—å?)
        *   **–°–æ—Å—Ç–æ—è–Ω–∏–µ:** –ü–æ–∑–≤–æ–ª—è–µ—Ç –ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ —Å–æ–≤–µ—Ä—à–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ? (–ù–∞–ø—Ä–∏–º–µ—Ä, –æ–Ω –Ω–µ –º–æ–∂–µ—Ç —á–∏—Ç–∞—Ç—å –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ, –µ—Å–ª–∏ –Ω–∞ –Ω–µ–≥–æ –Ω–∞–ª–æ–∂–µ–Ω —ç—Ñ—Ñ–µ–∫—Ç <span class="condition">–±–µ–∑–º–æ–ª–≤–∏–µ</span>).
        *   **–û–∫—Ä—É–∂–µ–Ω–∏–µ:** –ü–æ–∑–≤–æ–ª—è–µ—Ç –ª–∏ –æ–∫—Ä—É–∂–µ–Ω–∏–µ —Å–æ–≤–µ—Ä—à–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ? (–ù–∞–ø—Ä–∏–º–µ—Ä, –Ω–µ–ª—å–∑—è –≤—ã—Å—Ç—Ä–µ–ª–∏—Ç—å –∏–∑ –ª—É–∫–∞, –µ—Å–ª–∏ –æ–Ω –≤–ø–ª–æ—Ç–Ω—É—é –ø—Ä–∏–∂–∞—Ç –∫ —Å—Ç–µ–Ω–µ).
    3.  **–ï—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ –ù–ï–í–û–ó–ú–û–ñ–ù–û (`is_legal` –±—É–¥–µ—Ç `false`):**
        *   –¢–≤–æ–π `narrative_description` –î–û–õ–ñ–ï–ù –≤–µ–∂–ª–∏–≤–æ –∏ —è—Å–Ω–æ –æ–±—ä—è—Å–Ω–∏—Ç—å –∏–≥—Ä–æ–∫—É, –ø–æ—á–µ–º—É –µ–≥–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.
        *   –ü–æ–ª–µ `structural_changes` –î–û–õ–ñ–ù–û –±—ã—Ç—å –ø—É—Å—Ç—ã–º (`[]`).
        *   **–ü—Ä–∏–º–µ—Ä:** –ï—Å–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂ –±–µ–∑ –º–µ—á–∞ –ø—ã—Ç–∞–µ—Ç—Å—è "—É–¥–∞—Ä–∏—Ç—å –º–µ—á–æ–º", –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: `is_legal: false`, `narrative_description: "–í—ã —Ö–≤–∞—Ç–∞–µ—Ç–µ—Å—å –∑–∞ –ø–æ—è—Å, —á—Ç–æ–±—ã –≤—ã—Ç–∞—â–∏—Ç—å –º–µ—á, –Ω–æ –Ω–∞—â—É–ø—ã–≤–∞–µ—Ç–µ –ª–∏—à—å –ø—É—Å—Ç–æ–µ –º–µ—Å—Ç–æ. –í—ã –≤—Å–ø–æ–º–∏–Ω–∞–µ—Ç–µ, —á—Ç–æ –æ—Å—Ç–∞–≤–∏–ª–∏ –µ–≥–æ –≤ —Å–≤–æ–µ–π –∫–æ–º–Ω–∞—Ç–µ."`

    **–≠–¢–ê–ü 2: –°–ò–ú–£–õ–Ø–¶–ò–Ø –ò–°–•–û–î–ê (–ï–°–õ–ò –î–ï–ô–°–¢–í–ò–ï –í–û–ó–ú–û–ñ–ù–û)**
    1.  **–ò—Å–ø–æ–ª—å–∑—É–π –ª–æ–≥–∏–∫—É D&D:** –ï—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ (`is_legal: true`), —Å–∏–º—É–ª–∏—Ä—É–π –µ–≥–æ –∏—Å—Ö–æ–¥, –∫–∞–∫ –±—É–¥—Ç–æ —Ç—ã –±—Ä–æ—Å–∞–µ—à—å –∏–≥—Ä–æ–≤—ã–µ –∫–æ—Å—Ç–∏ (–∏–≥—Ä–æ–∫—É –ø–æ–∫–∞–∑—ã–≤–∞–π –∫—É–±–∏–∫–∏ –∏ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –±—Ä–æ—Å–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π <code>3 ( –∫—É–±–∏–∫ 1d4)</code> –¥–ª—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è –±—Ä–æ—Å–∫–æ–≤ –∏ –∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤).
        *   **–ê—Ç–∞–∫–∞:** –£—á–∏—Ç—ã–≤–∞–π –æ—Ä—É–∂–∏–µ –∞—Ç–∞–∫—É—é—â–µ–≥–æ, –µ–≥–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ (—Å–∏–ª–∞/–ª–æ–≤–∫–æ—Å—Ç—å) –∏ –ö–ª–∞—Å—Å –î–æ—Å–ø–µ—Ö–∞ (–ö–î) —Ü–µ–ª–∏. –ú–æ—â–Ω—ã–π —É–¥–∞—Ä —Å–µ–∫–∏—Ä–æ–π –¥–æ–ª–∂–µ–Ω –Ω–∞–Ω–æ—Å–∏—Ç—å –±–æ–ª—å—à–µ —É—Ä–æ–Ω–∞, —á–µ–º —É–∫–æ–ª –∫–∏–Ω–∂–∞–ª–æ–º.
        *   **–ó–∞–∫–ª–∏–Ω–∞–Ω–∏—è –∏ –≠—Ñ—Ñ–µ–∫—Ç—ã:** –ï—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, <span class="condition">–æ—Å–ª–µ–ø–ª–µ–Ω–∏–µ</span>, <span class="condition">–æ–≥–æ–Ω—å</span>), –æ–ø–∏—à–∏ —ç—Ç–æ –∏ –æ—Ç—Ä–∞–∑–∏ –≤ `structural_changes`.
        *   **–ü—Ä–æ–≤–µ—Ä–∫–∏ –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫:** –î–ª—è –¥–µ–π—Å—Ç–≤–∏–π –≤—Ä–æ–¥–µ "–ø–æ–ø—ã—Ç–∞—Ç—å—Å—è —É–±–µ–¥–∏—Ç—å —Å—Ç—Ä–∞–∂–Ω–∏–∫–∞" –∏–ª–∏ "–≤–∑–ª–æ–º–∞—Ç—å –∑–∞–º–æ–∫", –æ—Ü–µ–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å –∏ —à–∞–Ω—Å—ã –Ω–∞ —É—Å–ø–µ—Ö.
    2.  **–ë—É–¥—å –±–µ—Å–ø—Ä–∏—Å—Ç—Ä–∞—Å—Ç–µ–Ω:** –ù–µ –ø–æ–¥—Å—É–∂–∏–≤–∞–π –Ω–∏ –∏–≥—Ä–æ–∫–∞–º, –Ω–∏ –≤—Ä–∞–≥–∞–º. –ò—Å—Ö–æ–¥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ª–æ–≥–∏—á–Ω—ã–º —Å–ª–µ–¥—Å—Ç–≤–∏–µ–º –¥–µ–π—Å—Ç–≤–∏—è, —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –º–∏—Ä–∞.
    3.  **–û—Ç—Ä–∞–∂–∞–π –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:** –ö–∞–∂–¥–æ–µ –º–µ—Ö–∞–Ω–∏—á–µ—Å–∫–æ–µ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏–µ (—É—Ä–æ–Ω, –∏—Å—Ü–µ–ª–µ–Ω–∏–µ, –ø–æ—Ç—Ä–∞—á–µ–Ω–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç, –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞, –ø–æ—è–≤–ª–µ–Ω–∏–µ –≥–æ—Ä—è—â–µ–≥–æ —Å—Ç–æ–ª–∞) –î–û–õ–ñ–ù–û –±—ã—Ç—å –æ—Ç—Ä–∞–∂–µ–Ω–æ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç –≤ —Å–ø–∏—Å–∫–µ `structural_changes`.
    </RULES>

    <OUTPUT_FORMAT>
    –¢–≤–æ–π –æ—Ç–≤–µ—Ç –î–û–õ–ñ–ï–ù –±—ã—Ç—å –û–î–ù–ò–ú JSON-–æ–±—ä–µ–∫—Ç–æ–º, –ë–ï–ó –∫–∞–∫–∏—Ö-–ª–∏–±–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ—è—Å–Ω–µ–Ω–∏–π –∏–ª–∏ —Ç–µ–∫—Å—Ç–∞ –¥–æ/–ø–æ—Å–ª–µ –Ω–µ–≥–æ. JSON –¥–æ–ª–∂–µ–Ω —Å—Ç—Ä–æ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å Pydantic-–º–æ–¥–µ–ª–∏ `ActionOutcome`.
    -   `narrative_description`: –ö—Ä–∞—Å–æ—á–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∏–≥—Ä–æ–∫–∞. **–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û** –∏—Å–ø–æ–ª—å–∑—É–π —ç—Ç–∏ HTML-—Ç–µ–≥–∏:
        -   `<span class="name">–ò–º—è</span>` –¥–ª—è –∏–º–µ–Ω –∏ –Ω–∞–∑–≤–∞–Ω–∏–π.
        -   `<span class="damage">–æ–ø–∏—Å–∞–Ω–∏–µ —É—Ä–æ–Ω–∞</span>` –¥–ª—è –ª—é–±–æ–≥–æ –≤—Ä–µ–¥–∞.
        -   `<span class="heal">–æ–ø–∏—Å–∞–Ω–∏–µ –∏—Å—Ü–µ–ª–µ–Ω–∏—è</span>` –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∑–¥–æ—Ä–æ–≤—å—è.
        -   `<span class="condition">–æ–ø–∏—Å–∞–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è</span>` –¥–ª—è –Ω–∞–ª–æ–∂–µ–Ω–∏—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤.
    -   `structural_changes`: –°–ø–∏—Å–æ–∫ –æ–±—ä–µ–∫—Ç–æ–≤, –æ–ø–∏—Å—ã–≤–∞—é—â–∏—Ö –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è. –¢–∞–∫–∂–µ –∏—Å–ø–æ–ª—å–∑—É–π —Ç–µ–≥–∏. –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —É–∫–∞–∑—ã–≤–∞–π —á–∏—Å–ª–∞ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—Ä–æ—Å–∫–æ–≤, –∞ –Ω–µ —Å–∞–º–∏ –±—Ä–æ—Å–∫–∏. –ï—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ—Ç, –æ—Å—Ç–∞–≤—å –ø—É—Å—Ç—ã–º `[]`.
    -   `is_legal`: `true` –∏–ª–∏ `false`.
    Important: if for example a character took their sword and left it in the middle of the road it should be a change for the charactera and a cahnge for the scene as well.
    Example: if a character lightens up a bonfire you shoud come up with something like "LIght up a bonfire" - where object type is scene.
    Example: if a character uses a potion it should be removed from their inventory.
    </OUTPUT_FORMAT>

    <CONTEXT>
    {self.get_actual_context()}
    </CONTEXT>

    <TASK>
    –ü–µ—Ä—Å–æ–Ω–∞–∂ <span class="name">{character.name}</span> —Å–æ–≤–µ—Ä—à–∞–µ—Ç —Å–ª–µ–¥—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ: "{action_text}"

    –°–≥–µ–Ω–µ—Ä–∏—Ä—É–π JSON-–æ–±—ä–µ–∫—Ç `ActionOutcome`, –æ–ø–∏—Å—ã–≤–∞—é—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.
    </TASK>
    """

    # Inside ChapterLogicFight class

    def action(self, character: Character, action_text: str):
        """
        Executes an action and immediately gets both the narrative and the structured changes.
        """
        print(f"\n{ENTITY_COLOR}{character.name}{Colors.RESET} {INFO_COLOR}performs action:{Colors.RESET} {action_text}")

        # Use a generator that can directly output a Pydantic object
        # –ª–æ–ª
        # —ç—Ç–æ –≤–æ–æ–±—â–µ –Ω–µ —Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é —è —Å—é–¥–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–ª
        outcome: ActionOutcome = self.generator.generate(
            pydantic_model=ActionOutcome,
            prompt=self.get_action_prompt(character, action_text),
            language=self.language
        )

        narrative = outcome.narrative_description
        changes = outcome.structural_changes

        # The rest of the logic
        self.context += f"\n\n{character.name} tries to perform action {action_text}\n" # type: ignore
        yield EventBuilder.DM_message(narrative) # type: ignore

        if outcome.is_legal:
            for i, change in enumerate(changes, 1):
                self.context += f"<Action outcomes>"
                self.context += f"\n{i}. {change.object_name} -> ({change.changes})"
                if change.object_type == "character":
                    self.update_character(change.object_name, change.changes)
                elif change.object_type == "scene":
                    self.update_scene(change.object_name, change.changes)
                    
                yield EventBuilder.state_update_required(
                    update=f"{change.object_name} –±—ã–ª –æ–±–Ω–æ–≤–ª–µ–Ω ({change.changes})",
                    total=len(changes), 
                    current=i
                )
                yield EventBuilder.alert(f"{change.object_name}: {change.changes}")
            print(f"{SUCCESS_COLOR}All changes applied successfully{Colors.RESET}")    
            self.move_to_next_turn()
            self.context += f"</Action outcomes>"
        else:
            self.context += f"\nNothinig happens...\n"
            yield EventBuilder.alert("Impossible to act...")
    
    def askedDM(self, character: Character, question: str):
        """
        Handles a character asking the DM a question.
        
        :param character: The character asking the question.
        :param question: The question being asked.
        """
        print(f"\n{ENTITY_COLOR}{character.name}{Colors.RESET} {INFO_COLOR}asks:{Colors.RESET} {question}")
        prompt = f"""
        {global_defines.dungeon_master_core_prompt}
        [current task]
        –û—Ç–≤–µ—Ç—å –Ω–∞ –∑–∞–ø—Ä–æ—Å –∏–≥—Ä–æ–∫–∞, –≤—ã–¥–µ–ª—è—è –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —Ç–µ–≥–æ–º <span class='keyword'>–∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞</span> –∏ –≤—ã–¥–µ–ª—è—è –∏–º–µ–Ω–∞ —Ç–µ–≥–æ–º <span class='name'>–∏–º–µ–Ω–∞</span>. –°–µ–π—á–∞—Å —Ç—ã —Ç–æ–ª—å–∫–æ –æ—Ç–≤–µ—á–∞–µ—à—å –∏–≥—Ä–æ–∫—É, –∏, –∑–Ω–∞—á–∏—Ç, —Ç–≤–æ–π –æ—Ç–≤–µ—Ç –Ω–µ –¥–æ–ª–∂–µ–Ω –≤–ª–∏—è—Ç—å—å –Ω–∞ –º–∏—Ä –∏–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π. 
        [–ö–æ–Ω—Ç–µ–∫—Å—Ç]
        {self.get_actual_context()}
        [–ó–∞–ø—Ä–æ—Å] 
        "{question}"
        """
        reply = self.classifier.general_text_llm_request(prompt)
        self.context =  str(self.context) + f"<Chracter's interaction>{character.name} asks DM: {question}</Chracter's interaction>"
        self.context += f"<DM's response>\n{reply}</DM's response>\n"
        yield EventBuilder.DM_message(reply) # type: ignore
        # return reply

    def trim_context(self):
        print(f"\n{DEBUG_COLOR}Context trimming...{Colors.RED} {len(self.context)} chars of context {Colors.RESET}") # type: ignore
        print(f"{Colors.RED}context before{self.context}")
        self.context = self.classifier.general_text_llm_request(
            f"""
<ROLE>
–¢—ã ‚Äî –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –ú–∞—Å—Ç–µ—Ä–∞ –ò–≥—Ä—ã. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî —Å–∂–∞—Ç—å –¥–ª–∏–Ω–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é –≤ –∫—Ä–∞—Ç–∫—É—é, –Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—É—é —Å–≤–æ–¥–∫—É –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π —Å—Ü–µ–Ω—ã.
</ROLE>

<FULL_CONTEXT>
{self.get_actual_context()}
</FULL_CONTEXT>

<TASK>
–°–æ–∑–¥–∞–π –Ω–æ–≤—É—é —Å–≤–æ–¥–∫—É (–Ω–µ –±–æ–ª–µ–µ {MAX_CONTEXT_LENGTH} —Å–ª–æ–≤), –∫–æ—Ç–æ—Ä–∞—è —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–æ–ª—å–∫–æ —Å–∞–º—É—é –≤–∞–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –ø—Ä–µ–¥—Å—Ç–æ—è—â–µ–π —Å—Ü–µ–Ω—ã. –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∏ –≤ –Ω–µ–µ:
1.  **–û—Å–Ω–æ–≤–Ω–∞—è —Ü–µ–ª—å:** –ö–∞–∫–æ–≤–∞ –≥–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å –≥—Ä—É–ø–ø—ã –∞–≤–∞–Ω—Ç—é—Ä–∏—Å—Ç–æ–≤ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç?
2.  **–û—Å–Ω–æ–≤–Ω–∞—è —Ü–µ–ª—å –≤—Ä–∞–≥–æ–≤:** –ö–∞–∫–æ–≤–∞ –≥–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å –∏—Ö –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤?
3.  **–ö–ª—é—á–µ–≤—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è:** –ö–∞–∫–∏–µ —Å–æ—é–∑—ã –∏–ª–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã —Å—É—â–µ—Å—Ç–≤—É—é—Ç –º–µ–∂–¥—É –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º–∏?
4.  **–í–∞–∂–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –ø—Ä–æ—à–ª–æ–≥–æ:** –£–ø–æ–º—è–Ω–∏ 1-2 —Å–∞–º—ã—Ö –≤–∞–∂–Ω—ã—Ö —Å–æ–±—ã—Ç–∏—è –∏–∑ –ø—Ä–æ—à–ª–æ–≥–æ, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–ø—Ä—è–º—É—é –≤–ª–∏—è—é—Ç –Ω–∞ —Ç–µ–∫—É—â—É—é –º–æ—Ç–∏–≤–∞—Ü–∏—é –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π.
5.  **–ù–∞–º–µ—Ä–µ–Ω–∏–µ DM:** –ï—Å–ª–∏ –≤ —Ç–µ–∫—Å—Ç–µ –µ—Å—Ç—å –Ω–∞–º–µ–∫–∏ –Ω–∞ –±—É–¥—É—â–∏–µ —Å–æ–±—ã—Ç–∏—è –∏–ª–∏ —Å–µ–∫—Ä–µ—Ç—ã –æ—Ç –ú–∞—Å—Ç–µ—Ä–∞, —Å–æ—Ö—Ä–∞–Ω–∏ –∏—Ö.

–ù–µ –≤–∫–ª—é—á–∞–π –≤ —Å–≤–æ–¥–∫—É –Ω–µ—Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –∏–ª–∏ –æ–ø–∏—Å–∞–Ω–∏—è —É–∂–µ –ø—Ä–æ—à–µ–¥—à–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ –±—É–¥—É—â–µ–µ.
</TASK>
"""
        )
        print(f"{Colors.GREEN}context after{self.context} {Colors.RESET}")
        

    def process_interaction(self, character: Character, interaction: str):
        """
        Processes a character's interaction, deciding the outcome of actions and questions.
        """
        decision : ClassifyInformationOrActionRequest = self.classifier.generate(
            contents=f"""
            You need to classify players dnd request to DM (master). 
            –í `decision` TRUE, –µ—Å–ª–∏ –∑–∞–ø—Ä–æ—Å —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–ª–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –º–∞—Å—Ç–µ—Ä–æ–º –ø–æ–¥–∑–µ–º–µ–ª—å—è, FALSE, –µ—Å–ª–∏ –∑–∞–ø—Ä–æ—Å —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –æ—Ç –ª–∏—Ü–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –≤ D&D.
            player's request:
            {interaction}
            """, 
            pydantic_model=ClassifyInformationOrActionRequest
        )  # type: ignore
        if decision.decision: # type: ignore
            yield EventBuilder.user_intent_processed("info")
            print(f"{INFO_COLOR}Request for info {Colors.RESET}")
            yield from self.askedDM(character, interaction)
        else:
            yield EventBuilder.user_intent_processed("action")
            print(f"{INFO_COLOR}Request for action {Colors.RESET}")
            yield from self.action(character, interaction)
        self.after_turn()
    
    def get_character_by_name(self, name:str) -> Character:
        for char in self.characters:
            if  char.name == name:
                return char
        return self.characters[0]
    
    def after_turn(self):
        """
        Actions to perform after each player's turn.
        """
        print(f"\n{INFO_COLOR}üìù Processing after-turn effects...{Colors.YELLOW} {len(self.context)} chars of context {Colors.RESET}") # type: ignore
        if len(self.context) > MAX_CONTEXT_LENGTH_CHARS:  # type: ignore
            self.trim_context()
            if self.context: 
                print(f"{SUCCESS_COLOR}‚ú® Context updated{Colors.RESET}")

    def NPC_turn(self):
        """
        Handles the npc's turn in the fight.
        """
        print(f"\n{HEADER_COLOR}NPC's turn:{Colors.RESET}")
        # Here you can implement enemy actions, AI logic, etc.
        # For now, we will just simulate an enemy action
        NPC_action_prompt = f"""
<ROLE>
–¢—ã ‚Äî –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç, —É–ø—Ä–∞–≤–ª—è—é—â–∏–π –Ω–µ–∏–≥—Ä–æ–≤—ã–º –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º (NPC) –≤ –±–æ—é.
–¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –≤—ã–±—Ä–∞—Ç—å –Ω–∞–∏–±–æ–ª–µ–µ –ª–æ–≥–∏—á–Ω–æ–µ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ NPC –Ω–∞ –µ–≥–æ —Ö–æ–¥—É.
</ROLE>

<CHARACTER_PROFILE>
{self.get_active_character().model_dump_json(indent=2)}
</CHARACTER_PROFILE>

<SITUATION_CONTEXT>
{self.get_actual_context()}
</SITUATION_CONTEXT>

<TASK>
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –ª–∏—á–Ω–æ—Å—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞, –µ–≥–æ —Ü–µ–ª–∏ –∏ —Ç–µ–∫—É—â—É—é –±–æ–µ–≤—É—é –æ–±—Å—Ç–∞–Ω–æ–≤–∫—É. –í—ã–±–µ—Ä–∏ –µ–≥–æ —Å–ª–µ–¥—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ.
–¢–≤–æ–π –æ—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å **–∫–æ—Ä–æ—Ç–∫–æ–π —Ñ—Ä–∞–∑–æ–π, –æ–ø–∏—Å—ã–≤–∞—é—â–µ–π –¥–µ–π—Å—Ç–≤–∏–µ**, –∫–∞–∫ –±—É–¥—Ç–æ –µ–µ –≥–æ–≤–æ—Ä–∏—Ç –∏–≥—Ä–æ–∫.
–ù–µ –ø–∏—à–∏ –ø–æ–ª–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é, —Ç–æ–ª—å–∫–æ —Å–∞–º–æ –¥–µ–π—Å—Ç–≤–∏–µ.

–ü—Ä–∏–º–µ—Ä—ã —Ö–æ—Ä–æ—à–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤:
- "–ê—Ç–∞–∫—É—é –ë–æ—Ä–∏—Å–∞ –ë—Ä–∏—Ç–≤—É —Å–≤–æ–∏–º –ª–µ–¥—è–Ω—ã–º –∫–æ–ø—å–µ–º."
- "–ò—Å–ø–æ–ª—å–∑—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å '–õ–µ–¥—è–Ω–∞—è —Å—Ç–µ–Ω–∞', —á—Ç–æ–±—ã —Ä–∞–∑–¥–µ–ª–∏—Ç—å –≥—Ä—É–ø–ø—É."
- "–ü—ã—Ç–∞—é—Å—å –æ—Ç—Å—Ç—É–ø–∏—Ç—å –≤ —Ç–µ–Ω—å, —á—Ç–æ–±—ã –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –∑–∞—Å–∞–¥—É."

–¢–≤–æ–π –æ—Ç–≤–µ—Ç:
"""
        NPC_action = self.classifier.general_text_llm_request(NPC_action_prompt)
        yield from self.action(self.get_active_character(), NPC_action) # type: ignore
        
        
if __name__ == "__main__":
    load_dotenv()

    # character damage test
    # print(f"{HEADER_COLOR}üéÆ Starting new chapter...{Colors.RESET}")
    # chapter = ChapterLogicFight(context = "the journey begins...")
    # chapter.setup_fight()
    # r_ch = chapter.generator.generate(Character, "random character with full hp and no items in inventory", "no context", "Russian")
    # print(r_ch.model_dump_json(indent=2))
    # chapter.characters.append(r_ch)
    # chapter.update_character(r_ch.name, "–ø–æ–ª—É—á–∏–ª 10 —É—Ä–æ–Ω–∞ –∏ –ø–æ—Ç–µ—Ä—è–ª –≥–ª–∞–∑")
    # print(chapter.characters[0].model_dump_json(indent=2))
    
    # scene change test
    # print(f"{HEADER_COLOR}üéÆ Starting new chapter...{Colors.RESET}")
    # chapter = ChapterLogicFight(context = "the journey begins...")
    # chapter.setup_fight()
    # r_ch = chapter.generator.generate(Character, "random character with full hp and no items in inventory", "no context", "Russian")
    # print(r_ch.model_dump_json(indent=2))
    # chapter.characters.append(r_ch)
    # hhh = input("enter a question to a DM...    ")
    # print(chapter.process_interaction(chapter.characters[0], hhh)) # type: ignore
    
    
    # enemy turn test
    generator = ObjectGenerator()
    context = "A ground beneeth the grand tree"
    print(f"{HEADER_COLOR}üéÆ Starting new chapter (enemy turn test)...{Colors.RESET}")
    chapter = ChapterLogicFight(
        context = context,
        characters = [
            generator.generate(Character, "–ë–æ—Ä–∏—Å –ë—Ä–∏—Ç–≤–∞ with full hp (50 hp) and a single dager (player character)", context, "Russian"),
            generator.generate(Character, "random monster with full hp (50 hp) and some magic spells (enemy NPC)", context, "Russian")
        ]
    )
    chapter.setup_fight()
    def print_game_sate():
        for c in chapter.characters:
            print(c.model_dump_json(indent=2))
        print(chapter.scene.model_dump_json(indent=2)) # type: ignore
        print(chapter.turn_order)
    while True:
        if chapter.get_active_character().is_player:
            user_input = input(f"{ENTITY_COLOR}{chapter.get_active_character_name()} -->{Colors.RESET}  ")
            if user_input == "?": 
                print_game_sate()
                continue
            chapter.process_interaction(chapter.get_active_character(), user_input) # type: ignore
        else:
            dm_action = chapter.NPC_turn()